{{define "styles"}}
/* ===== Layout: full-screen fixed state machine ===== */
.scan-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none;
}
.scan-screen.active { display: flex; }

/* ===== Capture View ===== */
#captureView {
  background: #000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.capture-prompt {
  text-align: center; color: #fff; padding: 24px;
}
.capture-prompt p {
  font-size: 1.1rem; margin-bottom: 32px; opacity: 0.8;
}
.capture-label {
  display: inline-flex; align-items: center; justify-content: center;
  width: 80px; height: 80px; border-radius: 50%;
  border: 4px solid #fff; background: rgba(255,255,255,0.25);
  cursor: pointer; transition: background 0.2s;
}
.capture-label:active { background: rgba(255,255,255,0.55); }
.capture-label svg { width: 36px; height: 36px; fill: #fff; }
.capture-input { display: none; }

/* ===== Crop View ===== */
#cropView {
  background: #000;
  flex-direction: column;
}
#cropCanvas {
  flex: 1;
  width: 100%;
  display: block;
  touch-action: none;
}
.crop-controls {
  position: absolute; bottom: 0; left: 0; right: 0;
  padding: 16px 24px;
  display: flex; justify-content: center;
  background: linear-gradient(transparent, rgba(0,0,0,0.7));
  pointer-events: none;
}
.crop-controls button {
  pointer-events: auto;
}
.btn-confirm-crop {
  padding: 14px 48px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 600; cursor: pointer;
  background: #fff; color: #111;
}
.btn-confirm-crop:active { opacity: 0.85; }

/* ===== Preview View ===== */
#previewView {
  background: #111;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#previewImg {
  flex: 1;
  width: 100%;
  object-fit: contain;
  display: block;
}
.preview-controls {
  position: absolute; bottom: 0; left: 0; right: 0;
  padding: 16px 24px;
  display: flex; justify-content: space-between; align-items: center;
  background: linear-gradient(transparent, rgba(0,0,0,0.7));
}
.preview-btn {
  padding: 14px 24px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 500; cursor: pointer;
}
.btn-retake-scan  { background: rgba(255,255,255,0.2); color: #fff; }
.btn-recrop-scan  { background: rgba(255,255,255,0.12); color: #fff; }
.btn-accept-scan  { background: #fff; color: #111; font-weight: 600; }
.preview-btn:active { opacity: 0.8; }

/* ===== Review View (placeholder) ===== */
#reviewView {
  background: #111;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 1rem;
  opacity: 0.5;
}

/* ===== Filmstrip Bar (placeholder) ===== */
#filmstripBar {
  position: fixed; bottom: 0; left: 0; right: 0;
  height: 80px;
  background: #111;
  display: none;
}
#filmstripBar.active { display: flex; }

/* ===== Spinner Overlay ===== */
#spinnerView {
  background: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
  z-index: 200;
  flex-direction: column;
  gap: 16px;
}
.spinner {
  width: 52px; height: 52px; border: 4px solid rgba(255,255,255,0.3);
  border-top-color: #fff; border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
#spinnerLabel {
  color: #fff; font-size: 0.95rem; opacity: 0.85;
}
@keyframes spin { to { transform: rotate(360deg); } }
{{end}}

{{define "content"}}
<!-- Capture View -->
<div class="scan-screen active" id="captureView">
  <div class="capture-prompt">
    <p>Tap to open camera</p>
    <label class="capture-label" for="scanCameraInput">
      <svg viewBox="0 0 24 24">
        <path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4z"/>
        <path d="M9 2 7.17 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0-2-2h-3.17L15 2H9zm3 15a5 5 0 1 1 0-10 5 5 0 0 1 0 10z"/>
      </svg>
    </label>
    <input type="file" id="scanCameraInput" class="capture-input" accept="image/*">
  </div>
</div>

<!-- Crop View -->
<div class="scan-screen" id="cropView">
  <canvas id="cropCanvas"></canvas>
  <div class="crop-controls">
    <button class="btn-confirm-crop" onclick="window.confirmCrop()">Confirm</button>
  </div>
</div>

<!-- Preview View -->
<div class="scan-screen" id="previewView">
  <img id="previewImg" alt="Scanned document preview">
  <div class="preview-controls">
    <button class="preview-btn btn-retake-scan" onclick="window.retakeScan()">Retake</button>
    <button class="preview-btn btn-recrop-scan" onclick="window.recropScan()">Re-crop</button>
    <button class="preview-btn btn-accept-scan" id="acceptBtn" onclick="window.acceptPage()">Accept</button>
  </div>
</div>

<!-- Review View (placeholder — implemented in 06-03) -->
<div class="scan-screen" id="reviewView">
  <p>Review — coming in plan 06-03</p>
</div>

<!-- Filmstrip Bar (placeholder — implemented in 06-03) -->
<div id="filmstripBar"></div>

<!-- Spinner Overlay -->
<div class="scan-screen" id="spinnerView">
  <div class="spinner"></div>
  <span id="spinnerLabel"></span>
</div>
{{end}}

{{define "scripts"}}
<script type="module">
import { Homography } from "https://cdn.jsdelivr.net/gh/Eric-Canas/Homography.js@1.8.1/Homography.js";

// ===== Template data =====
const sessionID   = '{{.SessionID}}';
const documentMode = '{{.ScanDocumentMode}}';
const uploadURL   = '{{.ScanUploadURL}}';
const finalizeURL = '{{.ScanFinalizeURL}}';

// ===== State machine =====
let state = 'capture'; // 'capture' | 'crop' | 'preview' | 'review'

// ===== Crop state =====
let currentSourceCanvas = null; // offscreen canvas with EXIF-corrected pixels
let cropPoints = [];             // [[x,y],[x,y],[x,y],[x,y]] TL, TR, BR, BL in image pixel coords
let activeHandle = null;         // index 0-3 while dragging, or null
let scale   = 1;
let offsetX = 0, offsetY = 0;
let drawW   = 0, drawH   = 0;

// ===== Multi-page / warp state =====
let pages = [];               // [{docIndex, blob, thumbnailURL}]
let currentDocIndex = 0;
let currentWarpedBlob = null;
let currentThumbnailURL = null;

// ===== DOM refs =====
const cropCanvas   = document.getElementById('cropCanvas');
const cropCtx      = cropCanvas.getContext('2d');
const previewImg   = document.getElementById('previewImg');
const acceptBtn    = document.getElementById('acceptBtn');
const spinnerLabel = document.getElementById('spinnerLabel');

// ===== Screen switcher =====
const ALL_SCREENS = ['captureView', 'cropView', 'previewView', 'reviewView', 'spinnerView'];

function showScreen(name) {
  ALL_SCREENS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', id === name);
  });
  state = name === 'captureView' ? 'capture'
        : name === 'cropView'    ? 'crop'
        : name === 'previewView' ? 'preview'
        : name === 'reviewView'  ? 'review'
        : state;
}

function showSpinner(label) {
  spinnerLabel.textContent = label || '';
  ALL_SCREENS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', id === 'spinnerView');
  });
}

// ===== Camera input =====
const scanCameraInput = document.getElementById('scanCameraInput');
scanCameraInput.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  handleCapture(file);
});

// ===== EXIF normalization + capture handler =====
async function handleCapture(file) {
  currentSourceCanvas = await loadNormalizedImage(file);
  initCropAndShow();
}

function loadNormalizedImage(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.style.imageOrientation = 'from-image'; // CSS EXIF normalization
    img.onload = function() {
      const canvas = document.createElement('canvas');
      canvas.width  = img.naturalWidth;
      canvas.height = img.naturalHeight;
      canvas.getContext('2d').drawImage(img, 0, 0);
      URL.revokeObjectURL(img.src);
      resolve(canvas);
    };
    img.src = URL.createObjectURL(file);
  });
}

function initCropAndShow() {
  const w = currentSourceCanvas.width;
  const h = currentSourceCanvas.height;
  resizeCropCanvas();
  initCropPoints(w, h);
  showScreen('cropView');
  drawCropFrame();
}

function initCropPoints(w, h) {
  const m = 0.1;
  cropPoints = [
    [w * m,       h * m      ], // TL
    [w * (1 - m), h * m      ], // TR
    [w * (1 - m), h * (1 - m)], // BR
    [w * m,       h * (1 - m)], // BL
  ];
}

// ===== Crop canvas sizing =====
function resizeCropCanvas() {
  if (!currentSourceCanvas) return;
  const rect = cropCanvas.getBoundingClientRect();
  cropCanvas.width  = rect.width  || window.innerWidth;
  cropCanvas.height = rect.height || window.innerHeight;
  recalcLayout();
}

function recalcLayout() {
  const cw = cropCanvas.width;
  const ch = cropCanvas.height;
  const iw = currentSourceCanvas.width;
  const ih = currentSourceCanvas.height;
  scale = Math.min(cw / iw, ch / ih);
  drawW = iw * scale;
  drawH = ih * scale;
  offsetX = (cw - drawW) / 2;
  offsetY = (ch - drawH) / 2;
}

window.addEventListener('resize', () => {
  if (state === 'crop') {
    resizeCropCanvas();
    drawCropFrame();
  }
});

// ===== Crop frame rendering =====
const HIT_RADIUS    = 30; // px — touch target radius for corner hit detection
const BRACKET_LEN   = 20; // px — length of each L-bracket arm
const BRACKET_WIDTH = 3;  // px — L-bracket stroke width
const LINE_WIDTH    = 1.5;// px — connecting quad line width
const OVERLAY_ALPHA = 0.45;

function drawCropFrame() {
  if (!currentSourceCanvas || cropPoints.length < 4) return;

  const ctx = cropCtx;
  const cw  = cropCanvas.width;
  const ch  = cropCanvas.height;

  // Map crop points from image coords to canvas CSS-pixel coords
  const pts = cropPoints.map(([x, y]) => [
    x * scale + offsetX,
    y * scale + offsetY,
  ]);

  // 1. Clear and draw source image (letterboxed)
  ctx.clearRect(0, 0, cw, ch);
  ctx.drawImage(currentSourceCanvas, offsetX, offsetY, drawW, drawH);

  // 2. Semi-transparent dark overlay over entire canvas
  ctx.fillStyle = 'rgba(0,0,0,' + OVERLAY_ALPHA + ')';
  ctx.fillRect(0, 0, cw, ch);

  // 3. Punch out the crop quad using destination-out
  ctx.globalCompositeOperation = 'destination-out';
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0,0,0,1)';
  ctx.fill();
  ctx.globalCompositeOperation = 'source-over';

  // 4. Re-draw source image inside the quad only (clip to quad)
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(currentSourceCanvas, offsetX, offsetY, drawW, drawH);
  ctx.restore();

  // 5. Connecting white lines around the quad
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = LINE_WIDTH;
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.stroke();

  // 6. L-bracket corner handles
  drawHandles(ctx, pts);

  // 7. Loupe if a handle is being dragged
  if (activeHandle !== null) {
    const ap = pts[activeHandle];
    drawLoupe(ctx, ap[0], ap[1]);
  }
}

// ===== L-bracket handle drawing =====
const CORNER_DIRS = [
  [-1, -1], // TL: left, up
  [ 1, -1], // TR: right, up
  [ 1,  1], // BR: right, down
  [-1,  1], // BL: left, down
];

function drawHandles(ctx, pts) {
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = BRACKET_WIDTH;
  ctx.lineCap     = 'square';

  for (let i = 0; i < 4; i++) {
    const [cx, cy] = pts[i];
    const [dx, dy] = CORNER_DIRS[i];
    const L = BRACKET_LEN;

    ctx.beginPath();
    // Horizontal arm
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + dx * L, cy);
    // Vertical arm
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx, cy + dy * L);
    ctx.stroke();
  }

  ctx.lineCap = 'butt'; // reset
}

// ===== Magnifying glass loupe =====
const LOUPE_R     = 50; // px radius
const LOUPE_ZOOM  = 3;  // 3x magnification
const LOUPE_OFFSET_X = 80; // default horizontal offset from finger
const LOUPE_OFFSET_Y = 80; // default vertical offset (above finger)

function drawLoupe(ctx, canvasX, canvasY) {
  const imgX = (canvasX - offsetX) / scale;
  const imgY = (canvasY - offsetY) / scale;

  let loupeX = canvasX + LOUPE_OFFSET_X;
  let loupeY = canvasY - LOUPE_OFFSET_Y;

  if (canvasY < 150) {
    loupeY = canvasY + LOUPE_OFFSET_Y;
  }
  if (loupeX + LOUPE_R + 10 > cropCanvas.width) {
    loupeX = canvasX - LOUPE_OFFSET_X;
  }
  if (loupeX - LOUPE_R - 10 < 0) {
    loupeX = canvasX + LOUPE_OFFSET_X;
  }

  const srcW = (LOUPE_R * 2) / LOUPE_ZOOM;
  const srcH = (LOUPE_R * 2) / LOUPE_ZOOM;
  const srcX = imgX - srcW / 2;
  const srcY = imgY - srcH / 2;

  ctx.save();
  ctx.beginPath();
  ctx.arc(loupeX, loupeY, LOUPE_R, 0, Math.PI * 2);
  ctx.clip();
  ctx.drawImage(
    currentSourceCanvas,
    srcX, srcY, srcW, srcH,
    loupeX - LOUPE_R, loupeY - LOUPE_R, LOUPE_R * 2, LOUPE_R * 2
  );
  ctx.restore();

  ctx.beginPath();
  ctx.arc(loupeX, loupeY, LOUPE_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = 2;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(loupeX, loupeY, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#f00';
  ctx.fill();
}

// ===== Pointer events for corner dragging =====
cropCanvas.addEventListener('pointerdown', function(e) {
  if (cropPoints.length < 4) return;
  const rect = cropCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  for (let i = 0; i < 4; i++) {
    const hx = cropPoints[i][0] * scale + offsetX;
    const hy = cropPoints[i][1] * scale + offsetY;
    if (Math.hypot(x - hx, y - hy) < HIT_RADIUS) {
      activeHandle = i;
      cropCanvas.setPointerCapture(e.pointerId);
      break;
    }
  }
});

cropCanvas.addEventListener('pointermove', function(e) {
  if (activeHandle === null || cropPoints.length < 4) return;
  const rect = cropCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const imgX = Math.max(0, Math.min(currentSourceCanvas.width,  (x - offsetX) / scale));
  const imgY = Math.max(0, Math.min(currentSourceCanvas.height, (y - offsetY) / scale));
  cropPoints[activeHandle] = [imgX, imgY];

  drawCropFrame();
});

cropCanvas.addEventListener('pointerup', function() {
  activeHandle = null;
  drawCropFrame();
});

cropCanvas.addEventListener('pointercancel', function() {
  activeHandle = null;
  drawCropFrame();
});

// ===== Confirm Crop: perspective warp via Homography.js =====
async function confirmCrop() {
  if (!currentSourceCanvas || cropPoints.length < 4) return;

  showSpinner('Processing...');

  try {
    const W = currentSourceCanvas.width;
    const H = currentSourceCanvas.height;

    // Compute output dimensions from edge lengths
    const [tl, tr, br, bl] = cropPoints;
    const topLen    = Math.hypot(tr[0] - tl[0], tr[1] - tl[1]);
    const leftLen   = Math.hypot(bl[0] - tl[0], bl[1] - tl[1]);
    const bottomLen = Math.hypot(br[0] - bl[0], br[1] - bl[1]);
    const rightLen  = Math.hypot(br[0] - tr[0], br[1] - tr[1]);
    const outW = Math.round(Math.max(topLen, bottomLen));
    const outH = Math.round(Math.max(leftLen, rightLen));

    // Cap long side at 1500px to keep warp fast on mobile
    const MAX_SIDE = 1500;
    const longSide = Math.max(outW, outH);
    const warpScale = longSide > MAX_SIDE ? MAX_SIDE / longSide : 1;
    const finalW = Math.round(outW * warpScale);
    const finalH = Math.round(outH * warpScale);

    // Get ImageData from source canvas
    const srcCtx = currentSourceCanvas.getContext('2d');
    const imageData = srcCtx.getImageData(0, 0, W, H);

    // Normalize source points to 0..1 range
    const src = cropPoints.map(([x, y]) => [x / W, y / H]);
    // Destination = unit rectangle corners TL, TR, BR, BL
    const dst = [[0, 0], [1, 0], [1, 1], [0, 1]];

    // Perspective warp
    const h = new Homography("projective");
    h.setReferencePoints(src, dst, imageData);
    const warpedImageData = h.warp();

    // Render warped result to output canvas
    const outCanvas = document.createElement('canvas');
    outCanvas.width  = finalW;
    outCanvas.height = finalH;
    const outCtx = outCanvas.getContext('2d');

    // warp() returns ImageData at original ratio; scale it to finalW x finalH
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width  = warpedImageData.width;
    tempCanvas.height = warpedImageData.height;
    tempCanvas.getContext('2d').putImageData(warpedImageData, 0, 0);
    outCtx.drawImage(tempCanvas, 0, 0, finalW, finalH);

    // Convert to JPEG blob (0.9 quality) and store
    currentWarpedBlob = await new Promise(resolve => {
      outCanvas.toBlob(resolve, 'image/jpeg', 0.9);
    });

    // Generate thumbnail (max 56x64) for filmstrip in plan 06-03
    const thumbScale = Math.min(56 / finalW, 64 / finalH);
    const thumbW = Math.round(finalW * thumbScale);
    const thumbH = Math.round(finalH * thumbScale);
    const thumbCanvas = document.createElement('canvas');
    thumbCanvas.width  = thumbW;
    thumbCanvas.height = thumbH;
    thumbCanvas.getContext('2d').drawImage(outCanvas, 0, 0, thumbW, thumbH);
    if (currentThumbnailURL) URL.revokeObjectURL(currentThumbnailURL);
    currentThumbnailURL = await new Promise(resolve => {
      thumbCanvas.toBlob(blob => resolve(URL.createObjectURL(blob)), 'image/jpeg', 0.8);
    });

    // Show preview
    if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);
    previewImg.src = URL.createObjectURL(currentWarpedBlob);
    acceptBtn.disabled = false;

    showScreen('previewView');
  } catch (err) {
    showScreen('cropView');
    alert('Warp failed: ' + err.message);
  }
}

// ===== Preview actions =====

function retakeScan() {
  // Revoke URLs and clear all state, return to capture
  if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);
  if (currentThumbnailURL) { URL.revokeObjectURL(currentThumbnailURL); currentThumbnailURL = null; }
  currentWarpedBlob = null;
  currentSourceCanvas = null;
  cropPoints = [];
  scanCameraInput.value = '';
  showScreen('captureView');
}

function recropScan() {
  // Return to crop UI with same source image and current crop points
  showScreen('cropView');
  drawCropFrame();
}

async function acceptPage() {
  if (!currentWarpedBlob) return;

  if (documentMode === 'single') {
    // Single-page mode: upload + finalize + redirect
    acceptBtn.disabled = true;
    showSpinner('Uploading...');

    try {
      const fd = new FormData();
      fd.append('file', currentWarpedBlob, 'scan.jpg');
      fd.append('document_index', '0');
      fd.append('page_index', '0');

      const uploadResp = await fetch(uploadURL, { method: 'POST', body: fd });

      if (uploadResp.status === 410) {
        alert('Session expired.');
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (uploadResp.status === 409) {
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (!uploadResp.ok) {
        const err = await uploadResp.json().catch(() => ({}));
        throw new Error(err.error || 'Upload failed (' + uploadResp.status + ')');
      }

      const finalizeResp = await fetch(finalizeURL, { method: 'POST' });

      if (finalizeResp.status === 410) {
        alert('Session expired.');
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (!finalizeResp.ok) {
        const err = await finalizeResp.json().catch(() => ({}));
        throw new Error(err.error || 'Finalize failed (' + finalizeResp.status + ')');
      }

      // Cleanup object URLs
      if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);
      if (currentThumbnailURL) URL.revokeObjectURL(currentThumbnailURL);

      window.location.href = '/s/' + sessionID;
    } catch (err) {
      showScreen('previewView');
      acceptBtn.disabled = false;
      alert('Submit failed: ' + err.message);
    }
  } else {
    // Multi-page mode: store page and return to capture (filmstrip in plan 06-03)
    pages.push({
      docIndex: currentDocIndex,
      blob: currentWarpedBlob,
      thumbnailURL: currentThumbnailURL,
    });
    currentWarpedBlob = null;
    currentThumbnailURL = null;
    currentSourceCanvas = null;
    cropPoints = [];
    scanCameraInput.value = '';
    showScreen('captureView');
  }
}

// ===== Expose functions to window for onclick attributes =====
window.confirmCrop = confirmCrop;
window.retakeScan  = retakeScan;
window.recropScan  = recropScan;
window.acceptPage  = acceptPage;
</script>
{{end}}
