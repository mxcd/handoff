{{define "styles"}}
/* ===== Layout: full-screen fixed state machine ===== */
.scan-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none;
}
.scan-screen.active { display: flex; }

/* ===== Capture View ===== */
#captureView {
  background: #000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.capture-prompt {
  text-align: center; color: #fff; padding: 24px;
}
.capture-prompt p {
  font-size: 1.1rem; margin-bottom: 32px; opacity: 0.8;
}
.capture-label {
  display: inline-flex; align-items: center; justify-content: center;
  width: 80px; height: 80px; border-radius: 50%;
  border: 4px solid #fff; background: rgba(255,255,255,0.25);
  cursor: pointer; transition: background 0.2s;
}
.capture-label:active { background: rgba(255,255,255,0.55); }
.capture-label svg { width: 36px; height: 36px; fill: #fff; }
.capture-input { display: none; }

/* ===== Crop View ===== */
#cropView {
  background: #000;
  flex-direction: column;
}
#cropCanvas {
  flex: 1;
  width: 100%;
  display: block;
  touch-action: none;
}
.crop-controls {
  position: absolute; bottom: 0; left: 0; right: 0;
  padding: 16px 24px;
  display: flex; justify-content: center;
  background: linear-gradient(transparent, rgba(0,0,0,0.7));
  pointer-events: none;
}
.crop-controls button {
  pointer-events: auto;
}
.btn-confirm-crop {
  padding: 14px 48px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 600; cursor: pointer;
  background: #fff; color: #111;
}
.btn-confirm-crop:active { opacity: 0.85; }

/* ===== Preview View (placeholder) ===== */
#previewView {
  background: #111;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 1rem;
  opacity: 0.5;
}

/* ===== Review View (placeholder) ===== */
#reviewView {
  background: #111;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #fff;
  font-size: 1rem;
  opacity: 0.5;
}

/* ===== Filmstrip Bar (placeholder) ===== */
#filmstripBar {
  position: fixed; bottom: 0; left: 0; right: 0;
  height: 80px;
  background: #111;
  display: none;
}
#filmstripBar.active { display: flex; }

/* ===== Spinner Overlay ===== */
#spinnerView {
  background: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
  z-index: 200;
}
.spinner {
  width: 52px; height: 52px; border: 4px solid rgba(255,255,255,0.3);
  border-top-color: #fff; border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
{{end}}

{{define "content"}}
<!-- Capture View -->
<div class="scan-screen active" id="captureView">
  <div class="capture-prompt">
    <p>Tap to open camera</p>
    <label class="capture-label" for="scanCameraInput">
      <svg viewBox="0 0 24 24">
        <path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4z"/>
        <path d="M9 2 7.17 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-3.17L15 2H9zm3 15a5 5 0 1 1 0-10 5 5 0 0 1 0 10z"/>
      </svg>
    </label>
    <input type="file" id="scanCameraInput" class="capture-input" accept="image/*">
  </div>
</div>

<!-- Crop View -->
<div class="scan-screen" id="cropView">
  <canvas id="cropCanvas"></canvas>
  <div class="crop-controls">
    <button class="btn-confirm-crop" onclick="confirmCrop()">Confirm</button>
  </div>
</div>

<!-- Preview View (placeholder — implemented in 06-02) -->
<div class="scan-screen" id="previewView">
  <p>Preview — coming in plan 06-02</p>
</div>

<!-- Review View (placeholder — implemented in 06-03) -->
<div class="scan-screen" id="reviewView">
  <p>Review — coming in plan 06-03</p>
</div>

<!-- Filmstrip Bar (placeholder — implemented in 06-03) -->
<div id="filmstripBar"></div>

<!-- Spinner Overlay -->
<div class="scan-screen" id="spinnerView">
  <div class="spinner"></div>
</div>
{{end}}

{{define "scripts"}}
<script>
// ===== Template data =====
const sessionID   = '{{.SessionID}}';
const documentMode = '{{.ScanDocumentMode}}';
const uploadURL   = '{{.ScanUploadURL}}';
const finalizeURL = '{{.ScanFinalizeURL}}';

// ===== State machine =====
let state = 'capture'; // 'capture' | 'crop' | 'preview' | 'review'

// ===== Crop state =====
let currentSourceCanvas = null; // offscreen canvas with EXIF-corrected pixels
let cropPoints = [];             // [[x,y],[x,y],[x,y],[x,y]] TL, TR, BR, BL in image pixel coords
let activeHandle = null;         // index 0-3 while dragging, or null
let scale   = 1;
let offsetX = 0, offsetY = 0;
let drawW   = 0, drawH   = 0;

// ===== DOM refs =====
const cropCanvas   = document.getElementById('cropCanvas');
const cropCtx      = cropCanvas.getContext('2d');

// ===== Screen switcher =====
const ALL_SCREENS = ['captureView', 'cropView', 'previewView', 'reviewView', 'spinnerView'];

function showScreen(name) {
  ALL_SCREENS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', id === name);
  });
  state = name === 'captureView' ? 'capture'
        : name === 'cropView'    ? 'crop'
        : name === 'previewView' ? 'preview'
        : name === 'reviewView'  ? 'review'
        : state;
}

// ===== Camera input =====
const scanCameraInput = document.getElementById('scanCameraInput');
scanCameraInput.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  handleCapture(file);
});

// ===== EXIF normalization + capture handler =====
async function handleCapture(file) {
  currentSourceCanvas = await loadNormalizedImage(file);
  initCropAndShow();
}

function loadNormalizedImage(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.style.imageOrientation = 'from-image'; // CSS EXIF normalization
    img.onload = function() {
      const canvas = document.createElement('canvas');
      canvas.width  = img.naturalWidth;
      canvas.height = img.naturalHeight;
      canvas.getContext('2d').drawImage(img, 0, 0);
      URL.revokeObjectURL(img.src);
      resolve(canvas);
    };
    img.src = URL.createObjectURL(file);
  });
}

function initCropAndShow() {
  const w = currentSourceCanvas.width;
  const h = currentSourceCanvas.height;
  resizeCropCanvas();
  initCropPoints(w, h);
  showScreen('cropView');
  drawCropFrame();
}

function initCropPoints(w, h) {
  const m = 0.1;
  cropPoints = [
    [w * m,       h * m      ], // TL
    [w * (1 - m), h * m      ], // TR
    [w * (1 - m), h * (1 - m)], // BR
    [w * m,       h * (1 - m)], // BL
  ];
}

// ===== Crop canvas sizing =====
function resizeCropCanvas() {
  if (!currentSourceCanvas) return;
  // Canvas size = the CSS-pixel size of the element
  const rect = cropCanvas.getBoundingClientRect();
  cropCanvas.width  = rect.width  || window.innerWidth;
  cropCanvas.height = rect.height || (window.innerHeight - 0); // controls overlay, not above
  recalcLayout();
}

function recalcLayout() {
  const cw = cropCanvas.width;
  const ch = cropCanvas.height;
  const iw = currentSourceCanvas.width;
  const ih = currentSourceCanvas.height;
  scale = Math.min(cw / iw, ch / ih);
  drawW = iw * scale;
  drawH = ih * scale;
  offsetX = (cw - drawW) / 2;
  offsetY = (ch - drawH) / 2;
}

window.addEventListener('resize', () => {
  if (state === 'crop') {
    resizeCropCanvas();
    drawCropFrame();
  }
});

// ===== Crop frame rendering =====
const HIT_RADIUS    = 30; // px — touch target radius for corner hit detection
const BRACKET_LEN   = 20; // px — length of each L-bracket arm
const BRACKET_WIDTH = 3;  // px — L-bracket stroke width
const LINE_WIDTH    = 1.5;// px — connecting quad line width
const OVERLAY_ALPHA = 0.45;

function drawCropFrame() {
  if (!currentSourceCanvas || cropPoints.length < 4) return;

  const ctx = cropCtx;
  const cw  = cropCanvas.width;
  const ch  = cropCanvas.height;

  // Map crop points from image coords to canvas CSS-pixel coords
  const pts = cropPoints.map(([x, y]) => [
    x * scale + offsetX,
    y * scale + offsetY,
  ]);

  // 1. Clear and draw source image (letterboxed)
  ctx.clearRect(0, 0, cw, ch);
  ctx.drawImage(currentSourceCanvas, offsetX, offsetY, drawW, drawH);

  // 2. Semi-transparent dark overlay over entire canvas
  ctx.fillStyle = 'rgba(0,0,0,' + OVERLAY_ALPHA + ')';
  ctx.fillRect(0, 0, cw, ch);

  // 3. Punch out the crop quad using destination-out
  ctx.globalCompositeOperation = 'destination-out';
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0,0,0,1)';
  ctx.fill();
  ctx.globalCompositeOperation = 'source-over';

  // 4. Re-draw source image inside the quad only (clip to quad)
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(currentSourceCanvas, offsetX, offsetY, drawW, drawH);
  ctx.restore();

  // 5. Connecting white lines around the quad
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = LINE_WIDTH;
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.stroke();

  // 6. L-bracket corner handles
  drawHandles(ctx, pts);

  // 7. Loupe if a handle is being dragged
  if (activeHandle !== null) {
    const ap = pts[activeHandle];
    drawLoupe(ctx, ap[0], ap[1]);
  }
}

// ===== L-bracket handle drawing =====
// Arms extend AWAY from the quad center for each corner.
// Directions: TL(0)=left+up, TR(1)=right+up, BR(2)=right+down, BL(3)=left+down
const CORNER_DIRS = [
  [-1, -1], // TL: left, up
  [ 1, -1], // TR: right, up
  [ 1,  1], // BR: right, down
  [-1,  1], // BL: left, down
];

function drawHandles(ctx, pts) {
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = BRACKET_WIDTH;
  ctx.lineCap     = 'square';

  for (let i = 0; i < 4; i++) {
    const [cx, cy] = pts[i];
    const [dx, dy] = CORNER_DIRS[i];
    const L = BRACKET_LEN;

    ctx.beginPath();
    // Horizontal arm
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + dx * L, cy);
    // Vertical arm
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx, cy + dy * L);
    ctx.stroke();
  }

  ctx.lineCap = 'butt'; // reset
}

// ===== Magnifying glass loupe =====
const LOUPE_R     = 50; // px radius
const LOUPE_ZOOM  = 3;  // 3x magnification
const LOUPE_OFFSET_X = 80; // default horizontal offset from finger
const LOUPE_OFFSET_Y = 80; // default vertical offset (above finger)

function drawLoupe(ctx, canvasX, canvasY) {
  // Back-project canvas position to image pixel coords
  const imgX = (canvasX - offsetX) / scale;
  const imgY = (canvasY - offsetY) / scale;

  // Smart loupe positioning: default above+right, then adjust near edges
  let loupeX = canvasX + LOUPE_OFFSET_X;
  let loupeY = canvasY - LOUPE_OFFSET_Y;

  // Near top edge: shift loupe below
  if (canvasY < 150) {
    loupeY = canvasY + LOUPE_OFFSET_Y;
  }
  // Near right edge: shift loupe to the left
  if (loupeX + LOUPE_R + 10 > cropCanvas.width) {
    loupeX = canvasX - LOUPE_OFFSET_X;
  }
  // Near left edge: shift loupe to the right
  if (loupeX - LOUPE_R - 10 < 0) {
    loupeX = canvasX + LOUPE_OFFSET_X;
  }

  // Src region in the source image at 3x zoom
  const srcW = (LOUPE_R * 2) / LOUPE_ZOOM;
  const srcH = (LOUPE_R * 2) / LOUPE_ZOOM;
  const srcX = imgX - srcW / 2;
  const srcY = imgY - srcH / 2;

  // Draw zoomed source image into a clipped circle
  ctx.save();
  ctx.beginPath();
  ctx.arc(loupeX, loupeY, LOUPE_R, 0, Math.PI * 2);
  ctx.clip();
  ctx.drawImage(
    currentSourceCanvas,
    srcX, srcY, srcW, srcH,          // source region
    loupeX - LOUPE_R, loupeY - LOUPE_R, LOUPE_R * 2, LOUPE_R * 2 // dest
  );
  ctx.restore();

  // White border around loupe
  ctx.beginPath();
  ctx.arc(loupeX, loupeY, LOUPE_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = 2;
  ctx.stroke();

  // Red crosshair dot at loupe center (shows exact corner position)
  ctx.beginPath();
  ctx.arc(loupeX, loupeY, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#f00';
  ctx.fill();
}

// ===== Pointer events for corner dragging =====
cropCanvas.addEventListener('pointerdown', function(e) {
  if (cropPoints.length < 4) return;
  const rect = cropCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  for (let i = 0; i < 4; i++) {
    const hx = cropPoints[i][0] * scale + offsetX;
    const hy = cropPoints[i][1] * scale + offsetY;
    if (Math.hypot(x - hx, y - hy) < HIT_RADIUS) {
      activeHandle = i;
      cropCanvas.setPointerCapture(e.pointerId);
      break;
    }
  }
});

cropCanvas.addEventListener('pointermove', function(e) {
  if (activeHandle === null || cropPoints.length < 4) return;
  const rect = cropCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Convert canvas CSS-pixel position back to image pixel coords, clamped to image bounds
  const imgX = Math.max(0, Math.min(currentSourceCanvas.width,  (x - offsetX) / scale));
  const imgY = Math.max(0, Math.min(currentSourceCanvas.height, (y - offsetY) / scale));
  cropPoints[activeHandle] = [imgX, imgY];

  drawCropFrame();
});

cropCanvas.addEventListener('pointerup', function() {
  activeHandle = null;
  drawCropFrame(); // redraw without loupe
});

cropCanvas.addEventListener('pointercancel', function() {
  activeHandle = null;
  drawCropFrame();
});

// ===== Confirm Crop (stub for plan 06-02) =====
function confirmCrop() {
  // Plan 06-02 will implement perspective warp + preview here.
  console.log('crop confirmed', cropPoints.map(([x, y]) => [Math.round(x), Math.round(y)]));
}
</script>
{{end}}
