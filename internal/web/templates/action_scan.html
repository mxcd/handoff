{{define "styles"}}
/* ===== Layout: full-screen fixed state machine ===== */
.scan-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  display: none;
}
.scan-screen.active { display: flex; }

/* ===== Capture View ===== */
#captureView {
  background: #000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.capture-prompt {
  text-align: center; color: #fff; padding: 24px;
}
.capture-prompt p {
  font-size: 1.1rem; margin-bottom: 32px; opacity: 0.8;
}
.capture-label {
  display: inline-flex; align-items: center; justify-content: center;
  width: 80px; height: 80px; border-radius: 50%;
  border: 4px solid #fff; background: rgba(255,255,255,0.25);
  cursor: pointer; transition: background 0.2s;
}
.capture-label:active { background: rgba(255,255,255,0.55); }
.capture-label svg { width: 36px; height: 36px; fill: #fff; }
.capture-input { display: none; }

/* ===== Crop View ===== */
#cropView {
  background: #000;
  flex-direction: column;
}
#cropCanvas {
  flex: 1;
  width: 100%;
  display: block;
  touch-action: none;
}
.crop-controls {
  position: absolute; bottom: 0; left: 0; right: 0;
  padding: 16px 24px;
  display: flex; justify-content: center;
  background: linear-gradient(transparent, rgba(0,0,0,0.7));
  pointer-events: none;
}
.crop-controls button {
  pointer-events: auto;
}
.btn-confirm-crop {
  padding: 14px 48px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 600; cursor: pointer;
  background: #fff; color: #111;
}
.btn-confirm-crop:active { opacity: 0.85; }

/* ===== Preview View ===== */
#previewView {
  background: #111;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#previewImg {
  flex: 1;
  width: 100%;
  object-fit: contain;
  display: block;
}
.preview-controls {
  position: absolute; bottom: 0; left: 0; right: 0;
  padding: 16px 24px;
  display: flex; justify-content: space-between; align-items: center;
  background: linear-gradient(transparent, rgba(0,0,0,0.7));
}
.preview-btn {
  padding: 14px 24px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 500; cursor: pointer;
}
.btn-retake-scan  { background: rgba(255,255,255,0.2); color: #fff; }
.btn-recrop-scan  { background: rgba(255,255,255,0.12); color: #fff; }
.btn-accept-scan  { background: #fff; color: #111; font-weight: 600; }
.preview-btn:active { opacity: 0.8; }

/* ===== Filmstrip Bar ===== */
#filmstripBar {
  position: fixed; bottom: 0; left: 0; right: 0;
  background: #111;
  display: none;
  flex-direction: column;
  z-index: 100;
}
#filmstripBar.active { display: flex; }

.filmstrip-submit-row {
  display: flex;
  justify-content: flex-end;
  padding: 6px 12px 2px;
}
.btn-review-submit {
  padding: 8px 20px; border-radius: 8px; border: none;
  font-size: 0.9rem; font-weight: 600; cursor: pointer;
  background: #fff; color: #111;
}
.btn-review-submit:active { opacity: 0.8; }

.filmstrip {
  display: flex;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  gap: 8px;
  padding: 8px;
  background: #111;
  height: 80px;
  align-items: center;
  scroll-snap-type: x proximity;
}
.filmstrip-thumb {
  scroll-snap-align: start;
  flex-shrink: 0;
  width: 56px;
  height: 64px;
  position: relative;
  border-radius: 4px;
  overflow: hidden;
  border: 2px solid transparent;
  cursor: pointer;
  user-select: none;
  -webkit-user-select: none;
}
.filmstrip-thumb.selected { border-color: #fff; }
.filmstrip-thumb img { width: 100%; height: 100%; object-fit: cover; display: block; }
.filmstrip-page-num {
  position: absolute; bottom: 2px; right: 4px;
  font-size: 10px; color: #fff;
  background: rgba(0,0,0,0.6);
  padding: 1px 4px; border-radius: 2px;
  pointer-events: none;
}
.filmstrip-thumb.drag-ghost {
  opacity: 0.4;
}
.filmstrip-drag-clone {
  position: fixed;
  width: 56px;
  height: 64px;
  border-radius: 4px;
  overflow: hidden;
  border: 2px solid #fff;
  pointer-events: none;
  z-index: 300;
  opacity: 0.9;
  box-shadow: 0 4px 16px rgba(0,0,0,0.6);
}
.filmstrip-drag-clone img { width: 100%; height: 100%; object-fit: cover; display: block; }
.filmstrip-insert-line {
  position: absolute;
  width: 3px;
  height: 64px;
  background: #fff;
  border-radius: 2px;
  pointer-events: none;
  z-index: 200;
  top: 8px;
}
.filmstrip-doc-sep {
  flex-shrink: 0;
  width: 2px;
  height: 48px;
  background: #555;
  margin: 0 4px;
  position: relative;
}
.filmstrip-doc-label {
  position: absolute;
  top: -14px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 9px;
  color: #888;
  white-space: nowrap;
}
.filmstrip-btn {
  flex-shrink: 0;
  width: 56px;
  height: 64px;
  border-radius: 4px;
  border: 2px dashed #555;
  background: transparent;
  color: #888;
  font-size: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.filmstrip-btn:active { border-color: #aaa; color: #aaa; }

.filmstrip-delete-btn {
  position: absolute;
  top: 2px;
  right: 2px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: rgba(220,50,50,0.9);
  border: none;
  color: #fff;
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  line-height: 1;
  padding: 0;
}

/* ===== Review View ===== */
#reviewView {
  background: #000;
  flex-direction: column;
}
.review-container {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: #000; display: flex; flex-direction: column;
}
.review-header {
  padding: 16px; color: #fff; font-size: 1.2rem; font-weight: 600;
  text-align: center; border-bottom: 1px solid #333;
  flex-shrink: 0;
}
.review-content {
  flex: 1; overflow-y: auto; padding: 16px;
}
.review-doc-header {
  color: #ccc; font-size: 0.9rem; margin: 16px 0 8px;
}
.review-page-row {
  display: flex; gap: 12px; overflow-x: auto; padding-bottom: 16px;
}
.review-page-thumb {
  flex-shrink: 0; text-align: center;
}
.review-page-thumb img {
  width: 80px; height: 100px; object-fit: cover;
  border-radius: 4px; border: 1px solid #444; display: block;
}
.review-page-thumb span {
  display: block; font-size: 11px; color: #888; margin-top: 4px;
}
.review-controls {
  padding: 16px 24px;
  display: flex; justify-content: space-between; gap: 16px;
  background: #111; border-top: 1px solid #333;
  flex-shrink: 0;
}
.btn-review-back {
  padding: 14px 32px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 500; cursor: pointer;
  background: rgba(255,255,255,0.15); color: #fff;
  flex: 1;
}
.btn-review-confirm {
  padding: 14px 32px; border-radius: 8px; border: none;
  font-size: 1rem; font-weight: 600; cursor: pointer;
  background: #fff; color: #111;
  flex: 2;
}
.btn-review-back:active, .btn-review-confirm:active { opacity: 0.8; }

/* ===== Spinner Overlay ===== */
#spinnerView {
  background: rgba(0,0,0,0.75);
  align-items: center;
  justify-content: center;
  z-index: 200;
  flex-direction: column;
  gap: 16px;
}
.spinner {
  width: 52px; height: 52px; border: 4px solid rgba(255,255,255,0.3);
  border-top-color: #fff; border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
#spinnerLabel {
  color: #fff; font-size: 0.95rem; opacity: 0.85;
}
@keyframes spin { to { transform: rotate(360deg); } }
{{end}}

{{define "content"}}
<!-- Capture View -->
<div class="scan-screen active" id="captureView">
  <div class="capture-prompt">
    <p>Tap to open camera</p>
    <label class="capture-label" for="scanCameraInput">
      <svg viewBox="0 0 24 24">
        <path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4z"/>
        <path d="M9 2 7.17 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0-2-2h-3.17L15 2H9zm3 15a5 5 0 1 1 0-10 5 5 0 0 1 0 10z"/>
      </svg>
    </label>
    <input type="file" id="scanCameraInput" class="capture-input" accept="image/*">
  </div>
</div>

<!-- Crop View -->
<div class="scan-screen" id="cropView">
  <canvas id="cropCanvas"></canvas>
  <div class="crop-controls">
    <button class="btn-confirm-crop" onclick="window.confirmCrop()">Confirm</button>
  </div>
</div>

<!-- Preview View -->
<div class="scan-screen" id="previewView">
  <img id="previewImg" alt="Scanned document preview">
  <div class="preview-controls">
    <button class="preview-btn btn-retake-scan" onclick="window.retakeScan()">Retake</button>
    <button class="preview-btn btn-recrop-scan" onclick="window.recropScan()">Re-crop</button>
    <button class="preview-btn btn-accept-scan" id="acceptBtn" onclick="window.acceptPage()">Accept</button>
  </div>
</div>

<!-- Review View -->
<div class="scan-screen" id="reviewView">
  <div class="review-container">
    <div class="review-header">Review Scan</div>
    <div class="review-content" id="reviewContent"></div>
    <div class="review-controls">
      <button class="btn-review-back" onclick="window.hideReview()">Back</button>
      <button class="btn-review-confirm" id="reviewSubmitBtn" onclick="window.submitAllPages()">Submit</button>
    </div>
  </div>
</div>

<!-- Filmstrip Bar -->
<div id="filmstripBar">
  <div class="filmstrip-submit-row" id="filmstripSubmitRow" style="display:none;">
    <button class="btn-review-submit" onclick="window.showReview()">Review &amp; Submit</button>
  </div>
  <div class="filmstrip" id="filmstripContainer"></div>
</div>

<!-- Spinner Overlay -->
<div class="scan-screen" id="spinnerView">
  <div class="spinner"></div>
  <span id="spinnerLabel"></span>
</div>
{{end}}

{{define "scripts"}}
<script type="module">
import { Homography } from "https://cdn.jsdelivr.net/gh/Eric-Canas/Homography.js@1.8.1/Homography.js";

// ===== Template data =====
const sessionID   = '{{.SessionID}}';
const documentMode = '{{.ScanDocumentMode}}';
const uploadURL   = '{{.ScanUploadURL}}';
const finalizeURL = '{{.ScanFinalizeURL}}';

// ===== State machine =====
let state = 'capture'; // 'capture' | 'crop' | 'preview' | 'review'

// ===== Crop state =====
let currentSourceCanvas = null; // offscreen canvas with EXIF-corrected pixels
let cropPoints = [];             // [[x,y],[x,y],[x,y],[x,y]] TL, TR, BR, BL in image pixel coords
let activeHandle = null;         // index 0-3 while dragging, or null
let scale   = 1;
let offsetX = 0, offsetY = 0;
let drawW   = 0, drawH   = 0;

// ===== Multi-page / warp state =====
let pages = [];               // [{docIndex, blob, thumbnailURL}]
let currentDocIndex = 0;
let currentWarpedBlob = null;
let currentThumbnailURL = null;
let selectedPageIndex = -1;   // -1 = none selected

// ===== DOM refs =====
const cropCanvas        = document.getElementById('cropCanvas');
const cropCtx           = cropCanvas.getContext('2d');
const previewImg        = document.getElementById('previewImg');
const acceptBtn         = document.getElementById('acceptBtn');
const spinnerLabel      = document.getElementById('spinnerLabel');
const filmstripBar      = document.getElementById('filmstripBar');
const filmstripContainer = document.getElementById('filmstripContainer');
const filmstripSubmitRow = document.getElementById('filmstripSubmitRow');
const reviewSubmitBtn   = document.getElementById('reviewSubmitBtn');

// ===== Screen switcher =====
const ALL_SCREENS = ['captureView', 'cropView', 'previewView', 'reviewView', 'spinnerView'];

function showScreen(name) {
  ALL_SCREENS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', id === name + 'View' || (name === 'spinner' && id === 'spinnerView'));
  });

  // Map name to proper id suffix
  const idMap = {
    capture: 'captureView',
    crop:    'cropView',
    preview: 'previewView',
    review:  'reviewView',
    spinner: 'spinnerView',
  };
  ALL_SCREENS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', id === idMap[name]);
  });

  state = name;
  updateFilmstripVisibility();
}

function updateFilmstripVisibility() {
  const showFilmstrip = pages.length > 0 && (state === 'capture' || state === 'crop' || state === 'preview');
  filmstripBar.classList.toggle('active', showFilmstrip);
  filmstripSubmitRow.style.display = showFilmstrip ? 'flex' : 'none';
}

function showSpinner(label) {
  spinnerLabel.textContent = label || '';
  ALL_SCREENS.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('active', id === 'spinnerView');
  });
}

// ===== Camera input =====
const scanCameraInput = document.getElementById('scanCameraInput');
scanCameraInput.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;
  handleCapture(file);
});

// ===== EXIF normalization + capture handler =====
async function handleCapture(file) {
  currentSourceCanvas = await loadNormalizedImage(file);
  initCropAndShow();
}

function loadNormalizedImage(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.style.imageOrientation = 'from-image'; // CSS EXIF normalization
    img.onload = function() {
      const canvas = document.createElement('canvas');
      canvas.width  = img.naturalWidth;
      canvas.height = img.naturalHeight;
      canvas.getContext('2d').drawImage(img, 0, 0);
      URL.revokeObjectURL(img.src);
      resolve(canvas);
    };
    img.src = URL.createObjectURL(file);
  });
}

function initCropAndShow() {
  const w = currentSourceCanvas.width;
  const h = currentSourceCanvas.height;
  resizeCropCanvas();
  initCropPoints(w, h);
  showScreen('crop');
  drawCropFrame();
}

function initCropPoints(w, h) {
  const m = 0.1;
  cropPoints = [
    [w * m,       h * m      ], // TL
    [w * (1 - m), h * m      ], // TR
    [w * (1 - m), h * (1 - m)], // BR
    [w * m,       h * (1 - m)], // BL
  ];
}

// ===== Crop canvas sizing =====
function resizeCropCanvas() {
  if (!currentSourceCanvas) return;
  const rect = cropCanvas.getBoundingClientRect();
  cropCanvas.width  = rect.width  || window.innerWidth;
  cropCanvas.height = rect.height || window.innerHeight;
  recalcLayout();
}

function recalcLayout() {
  const cw = cropCanvas.width;
  const ch = cropCanvas.height;
  const iw = currentSourceCanvas.width;
  const ih = currentSourceCanvas.height;
  scale = Math.min(cw / iw, ch / ih);
  drawW = iw * scale;
  drawH = ih * scale;
  offsetX = (cw - drawW) / 2;
  offsetY = (ch - drawH) / 2;
}

window.addEventListener('resize', () => {
  if (state === 'crop') {
    resizeCropCanvas();
    drawCropFrame();
  }
});

// ===== Crop frame rendering =====
const HIT_RADIUS    = 30; // px — touch target radius for corner hit detection
const BRACKET_LEN   = 20; // px — length of each L-bracket arm
const BRACKET_WIDTH = 3;  // px — L-bracket stroke width
const LINE_WIDTH    = 1.5;// px — connecting quad line width
const OVERLAY_ALPHA = 0.45;

function drawCropFrame() {
  if (!currentSourceCanvas || cropPoints.length < 4) return;

  const ctx = cropCtx;
  const cw  = cropCanvas.width;
  const ch  = cropCanvas.height;

  // Map crop points from image coords to canvas CSS-pixel coords
  const pts = cropPoints.map(([x, y]) => [
    x * scale + offsetX,
    y * scale + offsetY,
  ]);

  // 1. Clear and draw source image (letterboxed)
  ctx.clearRect(0, 0, cw, ch);
  ctx.drawImage(currentSourceCanvas, offsetX, offsetY, drawW, drawH);

  // 2. Semi-transparent dark overlay over entire canvas
  ctx.fillStyle = 'rgba(0,0,0,' + OVERLAY_ALPHA + ')';
  ctx.fillRect(0, 0, cw, ch);

  // 3. Punch out the crop quad using destination-out
  ctx.globalCompositeOperation = 'destination-out';
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.fillStyle = 'rgba(0,0,0,1)';
  ctx.fill();
  ctx.globalCompositeOperation = 'source-over';

  // 4. Re-draw source image inside the quad only (clip to quad)
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.clip();
  ctx.drawImage(currentSourceCanvas, offsetX, offsetY, drawW, drawH);
  ctx.restore();

  // 5. Connecting white lines around the quad
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = LINE_WIDTH;
  ctx.beginPath();
  ctx.moveTo(pts[0][0], pts[0][1]);
  for (let i = 1; i < 4; i++) ctx.lineTo(pts[i][0], pts[i][1]);
  ctx.closePath();
  ctx.stroke();

  // 6. L-bracket corner handles
  drawHandles(ctx, pts);

  // 7. Loupe if a handle is being dragged
  if (activeHandle !== null) {
    const ap = pts[activeHandle];
    drawLoupe(ctx, ap[0], ap[1]);
  }
}

// ===== L-bracket handle drawing =====
const CORNER_DIRS = [
  [-1, -1], // TL: left, up
  [ 1, -1], // TR: right, up
  [ 1,  1], // BR: right, down
  [-1,  1], // BL: left, down
];

function drawHandles(ctx, pts) {
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = BRACKET_WIDTH;
  ctx.lineCap     = 'square';

  for (let i = 0; i < 4; i++) {
    const [cx, cy] = pts[i];
    const [dx, dy] = CORNER_DIRS[i];
    const L = BRACKET_LEN;

    ctx.beginPath();
    // Horizontal arm
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + dx * L, cy);
    // Vertical arm
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx, cy + dy * L);
    ctx.stroke();
  }

  ctx.lineCap = 'butt'; // reset
}

// ===== Magnifying glass loupe =====
const LOUPE_R     = 50; // px radius
const LOUPE_ZOOM  = 3;  // 3x magnification
const LOUPE_OFFSET_X = 80; // default horizontal offset from finger
const LOUPE_OFFSET_Y = 80; // default vertical offset (above finger)

function drawLoupe(ctx, canvasX, canvasY) {
  const imgX = (canvasX - offsetX) / scale;
  const imgY = (canvasY - offsetY) / scale;

  let loupeX = canvasX + LOUPE_OFFSET_X;
  let loupeY = canvasY - LOUPE_OFFSET_Y;

  if (canvasY < 150) {
    loupeY = canvasY + LOUPE_OFFSET_Y;
  }
  if (loupeX + LOUPE_R + 10 > cropCanvas.width) {
    loupeX = canvasX - LOUPE_OFFSET_X;
  }
  if (loupeX - LOUPE_R - 10 < 0) {
    loupeX = canvasX + LOUPE_OFFSET_X;
  }

  const srcW = (LOUPE_R * 2) / LOUPE_ZOOM;
  const srcH = (LOUPE_R * 2) / LOUPE_ZOOM;
  const srcX = imgX - srcW / 2;
  const srcY = imgY - srcH / 2;

  ctx.save();
  ctx.beginPath();
  ctx.arc(loupeX, loupeY, LOUPE_R, 0, Math.PI * 2);
  ctx.clip();
  ctx.drawImage(
    currentSourceCanvas,
    srcX, srcY, srcW, srcH,
    loupeX - LOUPE_R, loupeY - LOUPE_R, LOUPE_R * 2, LOUPE_R * 2
  );
  ctx.restore();

  ctx.beginPath();
  ctx.arc(loupeX, loupeY, LOUPE_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth   = 2;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(loupeX, loupeY, 3, 0, Math.PI * 2);
  ctx.fillStyle = '#f00';
  ctx.fill();
}

// ===== Pointer events for corner dragging =====
cropCanvas.addEventListener('pointerdown', function(e) {
  if (cropPoints.length < 4) return;
  const rect = cropCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  for (let i = 0; i < 4; i++) {
    const hx = cropPoints[i][0] * scale + offsetX;
    const hy = cropPoints[i][1] * scale + offsetY;
    if (Math.hypot(x - hx, y - hy) < HIT_RADIUS) {
      activeHandle = i;
      cropCanvas.setPointerCapture(e.pointerId);
      break;
    }
  }
});

cropCanvas.addEventListener('pointermove', function(e) {
  if (activeHandle === null || cropPoints.length < 4) return;
  const rect = cropCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const imgX = Math.max(0, Math.min(currentSourceCanvas.width,  (x - offsetX) / scale));
  const imgY = Math.max(0, Math.min(currentSourceCanvas.height, (y - offsetY) / scale));
  cropPoints[activeHandle] = [imgX, imgY];

  drawCropFrame();
});

cropCanvas.addEventListener('pointerup', function() {
  activeHandle = null;
  drawCropFrame();
});

cropCanvas.addEventListener('pointercancel', function() {
  activeHandle = null;
  drawCropFrame();
});

// ===== Confirm Crop: perspective warp via Homography.js =====
async function confirmCrop() {
  if (!currentSourceCanvas || cropPoints.length < 4) return;

  showSpinner('Processing...');

  try {
    const W = currentSourceCanvas.width;
    const H = currentSourceCanvas.height;

    // Compute output dimensions from edge lengths
    const [tl, tr, br, bl] = cropPoints;
    const topLen    = Math.hypot(tr[0] - tl[0], tr[1] - tl[1]);
    const leftLen   = Math.hypot(bl[0] - tl[0], bl[1] - tl[1]);
    const bottomLen = Math.hypot(br[0] - bl[0], br[1] - bl[1]);
    const rightLen  = Math.hypot(br[0] - tr[0], br[1] - tr[1]);
    const outW = Math.round(Math.max(topLen, bottomLen));
    const outH = Math.round(Math.max(leftLen, rightLen));

    // Cap long side at 1500px to keep warp fast on mobile
    const MAX_SIDE = 1500;
    const longSide = Math.max(outW, outH);
    const warpScale = longSide > MAX_SIDE ? MAX_SIDE / longSide : 1;
    const finalW = Math.round(outW * warpScale);
    const finalH = Math.round(outH * warpScale);

    // Get ImageData from source canvas
    const srcCtx = currentSourceCanvas.getContext('2d');
    const imageData = srcCtx.getImageData(0, 0, W, H);

    // Normalize source points to 0..1 range
    const src = cropPoints.map(([x, y]) => [x / W, y / H]);
    // Destination = unit rectangle corners TL, TR, BR, BL
    const dst = [[0, 0], [1, 0], [1, 1], [0, 1]];

    // Perspective warp
    const h = new Homography("projective");
    h.setReferencePoints(src, dst, imageData);
    const warpedImageData = h.warp();

    // Render warped result to output canvas
    const outCanvas = document.createElement('canvas');
    outCanvas.width  = finalW;
    outCanvas.height = finalH;
    const outCtx = outCanvas.getContext('2d');

    // warp() returns ImageData at original ratio; scale it to finalW x finalH
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width  = warpedImageData.width;
    tempCanvas.height = warpedImageData.height;
    tempCanvas.getContext('2d').putImageData(warpedImageData, 0, 0);
    outCtx.drawImage(tempCanvas, 0, 0, finalW, finalH);

    // Convert to JPEG blob (0.9 quality) and store
    currentWarpedBlob = await new Promise(resolve => {
      outCanvas.toBlob(resolve, 'image/jpeg', 0.9);
    });

    // Generate thumbnail (max 56x64) for filmstrip
    const thumbScale = Math.min(56 / finalW, 64 / finalH);
    const thumbW = Math.round(finalW * thumbScale);
    const thumbH = Math.round(finalH * thumbScale);
    const thumbCanvas = document.createElement('canvas');
    thumbCanvas.width  = thumbW;
    thumbCanvas.height = thumbH;
    thumbCanvas.getContext('2d').drawImage(outCanvas, 0, 0, thumbW, thumbH);
    if (currentThumbnailURL) URL.revokeObjectURL(currentThumbnailURL);
    currentThumbnailURL = await new Promise(resolve => {
      thumbCanvas.toBlob(blob => resolve(URL.createObjectURL(blob)), 'image/jpeg', 0.8);
    });

    // Show preview
    if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);
    previewImg.src = URL.createObjectURL(currentWarpedBlob);
    acceptBtn.disabled = false;

    showScreen('preview');
  } catch (err) {
    showScreen('crop');
    alert('Warp failed: ' + err.message);
  }
}

// ===== Preview actions =====

function retakeScan() {
  // Revoke URLs and clear all state, return to capture
  if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);
  if (currentThumbnailURL) { URL.revokeObjectURL(currentThumbnailURL); currentThumbnailURL = null; }
  currentWarpedBlob = null;
  currentSourceCanvas = null;
  cropPoints = [];
  scanCameraInput.value = '';
  showScreen('capture');
}

function recropScan() {
  // Return to crop UI with same source image and current crop points
  showScreen('crop');
  drawCropFrame();
}

async function acceptPage() {
  if (!currentWarpedBlob) return;

  if (documentMode === 'single') {
    // Single-page mode: upload + finalize + redirect
    acceptBtn.disabled = true;
    showSpinner('Uploading...');

    try {
      const fd = new FormData();
      fd.append('file', currentWarpedBlob, 'scan.jpg');
      fd.append('document_index', '0');
      fd.append('page_index', '0');

      const uploadResp = await fetch(uploadURL, { method: 'POST', body: fd });

      if (uploadResp.status === 410) {
        alert('Session expired.');
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (uploadResp.status === 409) {
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (!uploadResp.ok) {
        const err = await uploadResp.json().catch(() => ({}));
        throw new Error(err.error || 'Upload failed (' + uploadResp.status + ')');
      }

      const finalizeResp = await fetch(finalizeURL, { method: 'POST' });

      if (finalizeResp.status === 410) {
        alert('Session expired.');
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (!finalizeResp.ok) {
        const err = await finalizeResp.json().catch(() => ({}));
        throw new Error(err.error || 'Finalize failed (' + finalizeResp.status + ')');
      }

      // Cleanup object URLs
      if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);
      if (currentThumbnailURL) URL.revokeObjectURL(currentThumbnailURL);

      window.location.href = '/s/' + sessionID;
    } catch (err) {
      showScreen('preview');
      acceptBtn.disabled = false;
      alert('Submit failed: ' + err.message);
    }
  } else {
    // Multi-page mode: store page, update filmstrip, return to capture
    pages.push({
      docIndex: currentDocIndex,
      blob: currentWarpedBlob,
      thumbnailURL: currentThumbnailURL,
    });
    currentWarpedBlob = null;
    currentThumbnailURL = null;
    currentSourceCanvas = null;
    cropPoints = [];
    scanCameraInput.value = '';
    renderFilmstrip();
    showScreen('capture');
  }
}

// ===== Filmstrip rendering =====

function renderFilmstrip() {
  filmstripContainer.innerHTML = '';

  let prevDocIndex = -1;

  // Per-doc page counters for display numbering
  const docPageCounters = {};

  pages.forEach((page, i) => {
    // Insert document separator when doc changes
    if (page.docIndex !== prevDocIndex && prevDocIndex !== -1) {
      const sep = document.createElement('div');
      sep.className = 'filmstrip-doc-sep';
      const label = document.createElement('span');
      label.className = 'filmstrip-doc-label';
      label.textContent = 'Doc ' + (page.docIndex + 1);
      sep.appendChild(label);
      filmstripContainer.appendChild(sep);
    }
    prevDocIndex = page.docIndex;

    // Calculate page number within document
    if (!(page.docIndex in docPageCounters)) docPageCounters[page.docIndex] = 0;
    const pageNumInDoc = ++docPageCounters[page.docIndex];

    const thumb = document.createElement('div');
    thumb.className = 'filmstrip-thumb' + (i === selectedPageIndex ? ' selected' : '');
    thumb.dataset.index = i;

    const img = document.createElement('img');
    img.src = page.thumbnailURL;
    img.alt = 'Page ' + pageNumInDoc;
    thumb.appendChild(img);

    const badge = document.createElement('span');
    badge.className = 'filmstrip-page-num';
    badge.textContent = pageNumInDoc;
    thumb.appendChild(badge);

    // Show delete button on selected thumbnail
    if (i === selectedPageIndex) {
      const delBtn = document.createElement('button');
      delBtn.className = 'filmstrip-delete-btn';
      delBtn.title = 'Delete page';
      delBtn.innerHTML = '&#10005;';
      delBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        deletePage(i);
      });
      thumb.appendChild(delBtn);
    }

    // Tap to select/deselect
    thumb.addEventListener('click', function(e) {
      if (selectedPageIndex === i) {
        selectedPageIndex = -1;
      } else {
        selectedPageIndex = i;
      }
      renderFilmstrip();
    });

    // Long-press drag to reorder
    setupDragToReorder(thumb, i);

    filmstripContainer.appendChild(thumb);
  });

  // "Add Page" button
  const addBtn = document.createElement('button');
  addBtn.className = 'filmstrip-btn';
  addBtn.title = 'Add page';
  addBtn.innerHTML = '+';
  addBtn.addEventListener('click', function() {
    selectedPageIndex = -1;
    showScreen('capture');
  });
  filmstripContainer.appendChild(addBtn);

  // "Next Document" button — only in multi-document mode
  if (documentMode === 'multi') {
    const nextDocBtn = document.createElement('button');
    nextDocBtn.className = 'filmstrip-btn';
    nextDocBtn.title = 'Next document';
    nextDocBtn.innerHTML = '&#8594;';
    nextDocBtn.style.fontSize = '20px';
    nextDocBtn.addEventListener('click', function() {
      nextDocument();
    });
    filmstripContainer.appendChild(nextDocBtn);
  }

  // Auto-scroll filmstrip to end to show latest and action buttons
  filmstripContainer.scrollLeft = filmstripContainer.scrollWidth;

  updateFilmstripVisibility();
}

function deletePage(index) {
  if (index < 0 || index >= pages.length) return;
  // Revoke object URLs
  if (pages[index].thumbnailURL) URL.revokeObjectURL(pages[index].thumbnailURL);
  // Note: blobs themselves are GC'd when no longer referenced

  pages.splice(index, 1);
  selectedPageIndex = -1;
  renderFilmstrip();
}

// ===== Long-press drag to reorder =====

function setupDragToReorder(thumbEl, pageIndex) {
  let longPressTimer = null;
  let startX = 0;
  let startY = 0;
  let dragClone = null;
  let dragging = false;
  let dragIndex = pageIndex;
  let insertIndex = pageIndex;
  let insertLine = null;

  function onPointerDown(e) {
    startX = e.clientX;
    startY = e.clientY;

    longPressTimer = setTimeout(function() {
      longPressTimer = null;
      enterDragMode(e);
    }, 500);
    // Do NOT call preventDefault — preserves scroll behavior
  }

  function onPointerMove(e) {
    if (!dragging) {
      // If moved more than 5px, cancel the long-press timer
      const dist = Math.hypot(e.clientX - startX, e.clientY - startY);
      if (dist > 5 && longPressTimer !== null) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      return;
    }

    e.preventDefault();

    // Move clone to follow pointer
    if (dragClone) {
      dragClone.style.left = (e.clientX - 28) + 'px';
      dragClone.style.top  = (e.clientY - 32) + 'px';
    }

    // Determine insertion position by comparing pointer X to thumbnail centers
    insertIndex = computeInsertIndex(e.clientX);
    updateInsertLine(insertIndex);
  }

  function onPointerUp(e) {
    if (longPressTimer !== null) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }

    if (!dragging) return;

    // Apply reorder
    endDragMode();
    if (insertIndex !== dragIndex && insertIndex !== dragIndex + 1) {
      reorderPages(dragIndex, insertIndex);
    }
  }

  function onPointerCancel() {
    if (longPressTimer !== null) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
    if (dragging) {
      endDragMode();
    }
  }

  function enterDragMode(e) {
    dragging = true;
    dragIndex = pageIndex;
    insertIndex = pageIndex;

    // Clone the thumbnail as a floating drag proxy
    const rect = thumbEl.getBoundingClientRect();
    dragClone = document.createElement('div');
    dragClone.className = 'filmstrip-drag-clone';
    const cloneImg = document.createElement('img');
    cloneImg.src = pages[pageIndex].thumbnailURL;
    dragClone.appendChild(cloneImg);
    dragClone.style.left = (e.clientX - 28) + 'px';
    dragClone.style.top  = (e.clientY - 32) + 'px';
    document.body.appendChild(dragClone);

    // Dim the original thumbnail
    thumbEl.classList.add('drag-ghost');

    // Create insert line indicator
    insertLine = document.createElement('div');
    insertLine.className = 'filmstrip-insert-line';
    filmstripContainer.style.position = 'relative';
    filmstripContainer.appendChild(insertLine);
    updateInsertLine(insertIndex);

    thumbEl.setPointerCapture(e.pointerId);
  }

  function endDragMode() {
    dragging = false;
    thumbEl.classList.remove('drag-ghost');

    if (dragClone) {
      dragClone.remove();
      dragClone = null;
    }
    if (insertLine) {
      insertLine.remove();
      insertLine = null;
    }
  }

  function computeInsertIndex(pointerX) {
    const thumbEls = filmstripContainer.querySelectorAll('.filmstrip-thumb');
    const filmRect = filmstripContainer.getBoundingClientRect();
    const scrollLeft = filmstripContainer.scrollLeft;

    for (let i = 0; i < thumbEls.length; i++) {
      const r = thumbEls[i].getBoundingClientRect();
      const centerX = r.left + r.width / 2;
      if (pointerX < centerX) return i;
    }
    return thumbEls.length;
  }

  function updateInsertLine(idx) {
    if (!insertLine) return;
    const thumbEls = filmstripContainer.querySelectorAll('.filmstrip-thumb');
    const filmRect = filmstripContainer.getBoundingClientRect();
    const scrollLeft = filmstripContainer.scrollLeft;

    let lineX;
    if (idx < thumbEls.length) {
      const r = thumbEls[idx].getBoundingClientRect();
      lineX = r.left - filmRect.left + scrollLeft - 6;
    } else if (thumbEls.length > 0) {
      const r = thumbEls[thumbEls.length - 1].getBoundingClientRect();
      lineX = r.right - filmRect.left + scrollLeft + 4;
    } else {
      lineX = 8;
    }
    insertLine.style.left = lineX + 'px';
  }

  thumbEl.addEventListener('pointerdown', onPointerDown);
  thumbEl.addEventListener('pointermove', onPointerMove);
  thumbEl.addEventListener('pointerup', onPointerUp);
  thumbEl.addEventListener('pointercancel', onPointerCancel);
}

function reorderPages(fromIndex, toIndex) {
  if (fromIndex === toIndex) return;

  const page = pages.splice(fromIndex, 1)[0];
  // If we removed an item before the target, adjust target index
  const adjustedTo = toIndex > fromIndex ? toIndex - 1 : toIndex;
  pages.splice(adjustedTo, 0, page);

  selectedPageIndex = -1;
  renderFilmstrip();
}

// ===== Document boundaries (multi-document mode) =====

function nextDocument() {
  currentDocIndex++;
  renderFilmstrip();
  showScreen('capture');
}

// ===== Review screen =====

function showReview() {
  const reviewContent = document.getElementById('reviewContent');
  reviewContent.innerHTML = '';

  // Group pages by docIndex
  const docGroups = {};
  pages.forEach((p, i) => {
    if (!docGroups[p.docIndex]) docGroups[p.docIndex] = [];
    docGroups[p.docIndex].push({ ...p, globalIndex: i });
  });

  const docIndexes = Object.keys(docGroups).map(Number).sort((a, b) => a - b);

  for (const di of docIndexes) {
    // Add doc header only when multiple documents
    if (docIndexes.length > 1) {
      const header = document.createElement('h3');
      header.textContent = 'Document ' + (di + 1);
      header.className = 'review-doc-header';
      reviewContent.appendChild(header);
    }

    const row = document.createElement('div');
    row.className = 'review-page-row';

    docGroups[di].forEach(function(page, pageNumInDoc) {
      const thumb = document.createElement('div');
      thumb.className = 'review-page-thumb';

      const img = document.createElement('img');
      img.src = page.thumbnailURL;
      img.alt = 'Page ' + (pageNumInDoc + 1);
      thumb.appendChild(img);

      const label = document.createElement('span');
      label.textContent = 'Page ' + (pageNumInDoc + 1);
      thumb.appendChild(label);

      row.appendChild(thumb);
    });

    reviewContent.appendChild(row);
  }

  showScreen('review');
}

function hideReview() {
  showScreen('capture');
  renderFilmstrip();
}

// ===== Batch submission =====

async function submitAllPages() {
  if (pages.length === 0) return;

  reviewSubmitBtn.disabled = true;
  showSpinner('Preparing upload...');

  try {
    // Assign sequential page_index values within each document group
    const docPageCounters = {};
    for (const page of pages) {
      if (!(page.docIndex in docPageCounters)) docPageCounters[page.docIndex] = 0;
      page.pageIndex = docPageCounters[page.docIndex]++;
    }

    // Upload each page sequentially with progress feedback
    for (let i = 0; i < pages.length; i++) {
      const page = pages[i];
      spinnerLabel.textContent = 'Uploading page ' + (i + 1) + ' of ' + pages.length + '...';

      const fd = new FormData();
      fd.append('file', page.blob, 'scan.jpg');
      fd.append('document_index', String(page.docIndex));
      fd.append('page_index', String(page.pageIndex));

      const res = await fetch(uploadURL, { method: 'POST', body: fd });

      if (res.status === 410) {
        alert('Session expired.');
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (res.status === 409) {
        window.location.href = '/s/' + sessionID;
        return;
      }
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || 'Upload failed for page ' + (i + 1));
      }
    }

    // Call finalize
    spinnerLabel.textContent = 'Finalizing...';
    const finalizeResp = await fetch(finalizeURL, { method: 'POST' });

    if (finalizeResp.status === 410) {
      alert('Session expired.');
      window.location.href = '/s/' + sessionID;
      return;
    }
    if (!finalizeResp.ok) {
      const err = await finalizeResp.json().catch(() => ({}));
      throw new Error(err.error || 'Finalize failed (' + finalizeResp.status + ')');
    }

    // Cleanup: revoke all object URLs
    for (const page of pages) {
      if (page.thumbnailURL) URL.revokeObjectURL(page.thumbnailURL);
    }
    if (previewImg.src.startsWith('blob:')) URL.revokeObjectURL(previewImg.src);

    window.location.href = '/s/' + sessionID;

  } catch (err) {
    // Re-enable review screen on error
    reviewSubmitBtn.disabled = false;
    showScreen('review');
    alert('Submit failed: ' + err.message);
  }
}

// ===== Expose functions to window for onclick attributes =====
window.confirmCrop    = confirmCrop;
window.retakeScan     = retakeScan;
window.recropScan     = recropScan;
window.acceptPage     = acceptPage;
window.showReview     = showReview;
window.hideReview     = hideReview;
window.submitAllPages = submitAllPages;
window.nextDocument   = nextDocument;
</script>
{{end}}
